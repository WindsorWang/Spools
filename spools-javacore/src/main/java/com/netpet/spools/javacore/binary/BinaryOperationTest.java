package com.netpet.spools.javacore.binary;

/**
 *  Java 位运算(移位、位与、或、异或、非）
 * Created by woncz on 2016/10/13.
 */
public class BinaryOperationTest {

    public static void main(String[] args) {
        int a = 1 << 30;
        int b = Integer.MAX_VALUE;

        System.out.println("a = " + a + ", b = " + b + ", b-a = " + (b - a));

        int c = 1;
        System.out.println(c >>> 20);

        System.out.println((-1 & 0x7FFFFFFF) % 20);

        // 1、左移( << )
        /*
         * 首先会将5转为2进制表示形式(java中，整数默认就是int类型,也就是32位):
         *
         * 0000 0000 0000 0000 0000 0000 0000 0101           然后左移2位后，低位补0：
         *
         * 0000 0000 0000 0000 0000 0000 0001 0100           换算成10进制为20
         */
        System.out.println(5<<2); // 运行结果是20

        // 2、右移( >> ) ，右移同理，只是方向不一样罢了(感觉和没说一样)
        /*
         * 还是先将5转为2进制表示形式：
         *
         * 0000 0000 0000 0000 0000 0000 0000 0101 然后右移2位，高位补0：
         *
         * 0000 0000 0000 0000 0000 0000 0000 0001
         */

        System.out.println(5>>2); // 运行结果是1

        System.out.println(-5>>2);

        System.out.println(Integer.toBinaryString(-5));

        System.out.println(Integer.toBinaryString(5));

        // 3、无符号右移( >>> )
        /*
         * 例如  -5换算成二进制后为：
         * 1111 1111 1111 1111 1111 1111 1111 1011   (刚开始接触二进制时，不知道最高位是用来表示正负之分的，当时就总想不通。。明明算起来得到的就是一个正数-_-)
         */
        System.out.println(5>>3);//结果是0
        System.out.println(-5>>3);//结果是-1
        System.out.println(-5>>>3);//结果是536870911

        int k = 1 << 30; // 1 << 30 | 1 << 5
        k = -1072745864;
        System.out.println("k:" + Integer.toBinaryString(k) + ",\tk=" + k);
        int h = 0;
        System.out.println("h:" + Integer.toBinaryString(h) + ",\th=" + h);
        h ^= k;
        System.out.println("h:" + Integer.toBinaryString(h) + ",\th=" + h);
        h ^= (h >>> 20) ^ (h >>> 12);
        System.out.println("h:" + Integer.toBinaryString(h)+ ",\th=" + h);
        int hash = h ^ (h >>> 7) ^ (h >>> 4);

        System.out.println("h:" + Integer.toBinaryString(hash) + ",\th=" + hash);

        System.out.println("Integer.hashCode() : " + new Integer(-32).hashCode());

        /*
         * 我们来看看它的移位过程(可以通过其结果换算成二进制进行对比)：
         *
         * 5换算成二进制： 0000 0000 0000 0000 0000 0000 0000 0101
         *
         * 5右移3位后结果为0，0的二进制为： 0000 0000 0000 0000 0000 0000 0000 0000        // (用0进行补位)
         *
         * -5换算成二进制： 1111 1111 1111 1111 1111 1111 1111 1011
         *
         * -5右移3位后结果为-1，-1的二进制为：
         *
         * 1111 1111 1111 1111 1111 1111 1111 1111   // (用1进行补位)
         *
         * -5无符号右移3位后的结果 536870911 换算成二进制：
         *
         * 0001 1111 1111 1111 1111 1111 1111 1111   // (用0进行补位)
         *
         * 通过其结果转换成二进制后，我们可以发现，正数右移，高位用0补，负数右移，高位用1补，当负数使用无符号右移时，用0进行部位(自然而然的，就由负数变成了正数了)
         *
         * 注意：笔者在这里说的是右移，高位补位的情况。正数或者负数左移，低位都是用0补。(自行测试)
         */

        // 4、位与( & )
        System.out.println(5 & 3);//结果为1

        /*
         * 还是老套路，将2个操作数和结果都转换为二进制进行比较：
         * 5转换为二进制：0000 0000 0000 0000 0000 0000 0000 0101
         *
         * 3转换为二进制：0000 0000 0000 0000 0000 0000 0000 0011
         * -------------------------------------------------------------------------------------
         *
         * 1转换为二进制：0000 0000 0000 0000 0000 0000 0000 0001

         * 位与：第一个操作数的的第n位于第二个操作数的第n位如果都是1，那么结果的第n为也为1，否则为0
         */

        // 5、位或( | )
        System.out.println(5 | 3);//结果为7

        /*
         * 5转换为二进制：0000 0000 0000 0000 0000 0000 0000 0101
         *
         * 3转换为二进制：0000 0000 0000 0000 0000 0000 0000 0011
         *
         * -------------------------------------------------------------------------------------
         *
         * 7转换为二进制：0000 0000 0000 0000 0000 0000 0000 0111
         *
         * 位或操作：第一个操作数的的第n位于第二个操作数的第n位 只要有一个是1，那么结果的第n为也为1，否则为0
         */

        // 6、位异或( ^ )
        System.out.println(5 ^ 3);//结果为6

        /*
         * 5转换为二进制：0000 0000 0000 0000 0000 0000 0000 0101
         *
         * 3转换为二进制：0000 0000 0000 0000 0000 0000 0000 0011
         *
         * -------------------------------------------------------------------------------------
         *
         * 6转换为二进制：0000 0000 0000 0000 0000 0000 0000 0110
         *
         * 位异或：第一个操作数的的第n位于第二个操作数的第n位 相反，那么结果的第n为也为1，否则为0
         */

        // 7、位非( ~ )           位非是一元操作符
        System.out.println(~5);//结果为-6

        /*
         * 5转换为二进制：0000 0000 0000 0000 0000 0000 0000 0101
         * -------------------------------------------------------------------------------------
         * -6转换为二进制：1111 1111 1111 1111 1111 1111 1111 1010
         *
         * 位非：操作数的第n位为1，那么结果的第n位为0，反之。
         *
         * 由位运算操作符衍生而来的有：
         *
         * &= 按位与赋值
         * |=  按位或赋值
         * ^= 按位非赋值
         * >>= 右移赋值
         * >>>= 无符号右移赋值
         * <<= 赋值左移
         *
         * 和 += 一个概念而已。
         */

        a = 5;
        a &= 3;
        System.out.println(a);//结果是1
    }
}
